name: YouTube Download

on:
  workflow_dispatch:
    inputs:
      job_id:
        description: 'Unique job ID'
        required: true
        type: string
      video_url:
        description: 'YouTube video URL'
        required: true
        type: string
      format:
        description: 'Download format (best, bestaudio, 720p, 1080p, etc.)'
        required: false
        default: 'best'
        type: string
      audio_only:
        description: 'Extract audio only (true/false)'
        required: false
        default: 'false'
        type: string
      extract_url_only:
        description: 'Extract direct URL only without downloading (true/false)'
        required: false
        default: 'false'
        type: string
      callback_url:
        description: 'Callback URL after completion'
        required: true
        type: string
  repository_dispatch:
    types: [yt_download]

jobs:
  download:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Debug - Show event payload
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Job ID (inputs): ${{ github.event.inputs.job_id }}"
          echo "Job ID (client_payload): ${{ github.event.client_payload.job_id }}"
          echo "URL (inputs): ${{ github.event.inputs.video_url }}"
          echo "URL (client_payload): ${{ github.event.client_payload.url }}"
          echo "Format (inputs): ${{ github.event.inputs.format }}"
          echo "Format (client_payload): ${{ github.event.client_payload.format }}"
          echo "Callback (inputs): ${{ github.event.inputs.callback_url }}"
          echo "Callback (client_payload): ${{ github.event.client_payload.callback_url }}"
          echo "Extract URL only (inputs): ${{ github.event.inputs.extract_url_only }}"
          echo "Extract URL only (client_payload): ${{ github.event.client_payload.extract_url_only }}"
      
      - name: Install yt-dlp and ffmpeg
        run: |
          # Install latest yt-dlp from GitHub releases (most up-to-date)
          sudo curl -L https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp -o /usr/local/bin/yt-dlp
          sudo chmod a+rx /usr/local/bin/yt-dlp
          yt-dlp --version
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq
          pip install awscli
      
      - name: Create output directory and setup cookies
        run: |
          mkdir -p downloads
          # Create cookies file if YOUTUBE_COOKIES secret is provided
          # The secret should be base64 encoded
          if [ -n "${{ secrets.YOUTUBE_COOKIES }}" ]; then
            echo "Decoding YouTube cookies..."
            echo "${{ secrets.YOUTUBE_COOKIES }}" | base64 -d > cookies_raw.txt 2>/dev/null || echo "${{ secrets.YOUTUBE_COOKIES }}" > cookies_raw.txt
            # Convert Windows CRLF to Unix LF and remove any BOM
            sed 's/\r$//' cookies_raw.txt | sed '1s/^\xEF\xBB\xBF//' > cookies.txt
            rm -f cookies_raw.txt
            echo "YouTube cookies file created"
            echo "Cookies file size: $(wc -c < cookies.txt) bytes"
            echo "Cookies file lines: $(wc -l < cookies.txt)"
            # Verify format
            if head -1 cookies.txt | grep -q "Netscape"; then
              echo "✓ Valid Netscape cookie format detected"
            else
              echo "⚠ Warning: First line doesn't contain Netscape marker"
              echo "First line: $(head -1 cookies.txt | cut -c1-50)"
            fi
            # Count cookie entries (lines not starting with #)
            COOKIE_COUNT=$(grep -v '^#' cookies.txt | grep -v '^$' | wc -l)
            echo "Cookie entries found: $COOKIE_COUNT"
            # Show domain info (sanitized)
            echo "Domains in cookies:"
            grep -v '^#' cookies.txt | grep -v '^$' | cut -f1 | sort -u | head -10
          else
            echo "⚠ Warning: YOUTUBE_COOKIES secret not set"
          fi
      
      - name: Download video
        id: download
        env:
          YOUTUBE_COOKIES: ${{ secrets.YOUTUBE_COOKIES }}
        run: |
          VIDEO_URL="${{ github.event.inputs.video_url || github.event.client_payload.url }}"
          FORMAT="${{ github.event.inputs.format || github.event.client_payload.format }}"
          AUDIO_ONLY="${{ github.event.inputs.audio_only || github.event.client_payload.audio_only }}"
          EXTRACT_URL_ONLY="${{ github.event.inputs.extract_url_only || github.event.client_payload.extract_url_only }}"
          JOB_ID="${{ github.event.inputs.job_id || github.event.client_payload.job_id }}"
          
          echo "Downloading: $VIDEO_URL"
          echo "Format: $FORMAT"
          echo "Audio only: $AUDIO_ONLY"
          echo "Extract URL only: $EXTRACT_URL_ONLY"
          
          # Extract video ID from YouTube URL
          VIDEO_ID=$(echo "$VIDEO_URL" | grep -oP '(?:v=|youtu\.be/|shorts/)([a-zA-Z0-9_-]{11})' | head -1 | sed 's/v=//;s/youtu\.be\///;s/shorts\///')
          if [ -z "$VIDEO_ID" ]; then
            VIDEO_ID=$(echo "$VIDEO_URL" | grep -oE '[a-zA-Z0-9_-]{11}')
          fi
          echo "Video ID: $VIDEO_ID"
          
          # Check if cookies file exists and is valid
          if [ -f "cookies.txt" ]; then
            echo "=== Cookies file verification ==="
            echo "File exists: YES"
            echo "File size: $(wc -c < cookies.txt) bytes"
            COOKIES_OPT="--cookies cookies.txt"
          else
            echo "=== Cookies file NOT found! ==="
            COOKIES_OPT=""
          fi
          
          # ========================================
          # URL EXTRACTION ONLY MODE
          # ========================================
          if [ "$EXTRACT_URL_ONLY" = "true" ]; then
            echo "=== URL Extraction Mode ==="
            
            # Build format selector based on format
            case "$FORMAT" in
              "360p") FORMAT_SEL="bestvideo[height<=360]+bestaudio/best[height<=360]/best" ;;
              "480p") FORMAT_SEL="bestvideo[height<=480]+bestaudio/best[height<=480]/best" ;;
              "720p") FORMAT_SEL="bestvideo[height<=720]+bestaudio/best[height<=720]/best" ;;
              "1080p") FORMAT_SEL="bestvideo[height<=1080]+bestaudio/best[height<=1080]/best" ;;
              "bestaudio") FORMAT_SEL="bestaudio" ;;
              *) FORMAT_SEL="best" ;;
            esac
            
            if [ "$AUDIO_ONLY" = "true" ]; then
              FORMAT_SEL="bestaudio"
            fi
            
            EXTRACTED_URLS=""
            EXTRACTION_SUCCESS=false
            
            # Try different clients for URL extraction
            for CLIENT in "tv_embedded" "web" "ios" "android" "mweb"; do
              echo "=== Trying client: $CLIENT ==="
              
              # Run yt-dlp and capture both stdout and stderr
              set +e
              URLS=$(yt-dlp $COOKIES_OPT \
                --extractor-args "youtube:player_client=$CLIENT" \
                -f "$FORMAT_SEL" \
                --no-warnings \
                -g "$VIDEO_URL" 2>&1)
              EXIT_CODE=$?
              set -e
              
              echo "Exit code: $EXIT_CODE"
              echo "Output: $URLS"
              
              # Check if URLs were extracted successfully
              if [ $EXIT_CODE -eq 0 ] && echo "$URLS" | grep -qE "https?://.*\.(googlevideo\.com|youtube\.com)"; then
                EXTRACTED_URLS=$(echo "$URLS" | grep -E "https?://")
                EXTRACTION_SUCCESS=true
                echo "✓ URL extraction successful with $CLIENT client"
                break
              else
                echo "✗ Failed with $CLIENT client"
              fi
            done
            
            # If all clients failed, try with simpler format
            if [ "$EXTRACTION_SUCCESS" = "false" ]; then
              echo "=== Trying fallback with simple format ==="
              for CLIENT in "tv_embedded" "web"; do
                set +e
                URLS=$(yt-dlp $COOKIES_OPT \
                  --extractor-args "youtube:player_client=$CLIENT" \
                  -f "best" \
                  --no-warnings \
                  -g "$VIDEO_URL" 2>&1)
                EXIT_CODE=$?
                set -e
                
                if [ $EXIT_CODE -eq 0 ] && echo "$URLS" | grep -qE "https?://"; then
                  EXTRACTED_URLS=$(echo "$URLS" | grep -E "https?://")
                  EXTRACTION_SUCCESS=true
                  echo "✓ URL extraction successful with fallback ($CLIENT)"
                  break
                fi
              done
            fi
            
            if [ "$EXTRACTION_SUCCESS" = "false" ]; then
              echo "❌ URL extraction failed with all clients"
              echo "Last output: $URLS"
              # Set empty output so callback can handle the failure
              echo "extracted_urls=" >> $GITHUB_OUTPUT
              echo "title=extraction_failed" >> $GITHUB_OUTPUT
              echo "extract_mode=true" >> $GITHUB_OUTPUT
              exit 1
            fi
            
            # Get video title
            TITLE=$(yt-dlp $COOKIES_OPT --get-title "$VIDEO_URL" 2>/dev/null | head -1 | tr -cd '[:alnum:] ._-' | head -c 100)
            if [ -z "$TITLE" ]; then
              TITLE="video_$JOB_ID"
            fi
            
            # Output the extracted URLs (may be multiple lines for video+audio)
            echo "=== Extracted URLs ==="
            echo "$EXTRACTED_URLS"
            
            # Save URLs to file for the callback step
            echo "$EXTRACTED_URLS" > extracted_urls.txt
            
            # Set outputs
            echo "extracted_urls<<EOF" >> $GITHUB_OUTPUT
            echo "$EXTRACTED_URLS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "title=$TITLE" >> $GITHUB_OUTPUT
            echo "extract_mode=true" >> $GITHUB_OUTPUT
            
            exit 0
          fi
          
          # ========================================
          # NORMAL DOWNLOAD MODE
          # ========================================
          
          # Build yt-dlp command with anti-bot options
          # (Individual commands are built in each attempt section)
          
          if [ "$AUDIO_ONLY" = "true" ]; then
            YT_CMD="$YT_CMD -x --audio-format mp3 --audio-quality 0"
            EXT="mp3"
          else
            case "$FORMAT" in
              "best")
                YT_CMD="$YT_CMD -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "1080p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/best[height<=1080]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "720p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/best[height<=720]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "480p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=480][ext=mp4]+bestaudio[ext=m4a]/best[height<=480]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "360p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=360][ext=mp4]+bestaudio[ext=m4a]/best[height<=360]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "bestaudio")
                YT_CMD="$YT_CMD -x --audio-format mp3 --audio-quality 0"
                EXT="mp3"
                ;;
              *)
                YT_CMD="$YT_CMD -f '$FORMAT' --merge-output-format mp4"
                EXT="mp4"
                ;;
            esac
          fi
          
          # Get video title for filename
          TITLE=$(yt-dlp --get-title "$VIDEO_URL" 2>/dev/null | head -1 | tr -cd '[:alnum:] ._-' | head -c 100)
          if [ -z "$TITLE" ]; then
            TITLE="video_$JOB_ID"
          fi
          
          SAFE_TITLE=$(echo "$TITLE" | tr ' ' '_' | tr -cd '[:alnum:]._-')
          if [ -z "$SAFE_TITLE" ]; then
            SAFE_TITLE="video_$JOB_ID"
          fi
          OUTPUT_FILE="downloads/${SAFE_TITLE}.${EXT}"
          
          echo "Output file: $OUTPUT_FILE"
          
          # Try yt-dlp with different configurations
          DOWNLOAD_SUCCESS=false
          
          # Attempt 1: tv_embedded client with cookies
          echo "=== Attempt 1: yt-dlp with tv_embedded client ==="
          YT_CMD1="yt-dlp --verbose --no-warnings $COOKIES_OPT"
          YT_CMD1="$YT_CMD1 --extractor-args 'youtube:player_client=tv_embedded'"
          YT_CMD1="$YT_CMD1 --user-agent 'Mozilla/5.0 (ChromiumStylePlatform) Cobalt/Version'"
          case "$FORMAT" in
            "360p") YT_CMD1="$YT_CMD1 -f 'bestvideo[height<=360]+bestaudio/best[height<=360]/best'" ;;
            "480p") YT_CMD1="$YT_CMD1 -f 'bestvideo[height<=480]+bestaudio/best[height<=480]/best'" ;;
            "720p") YT_CMD1="$YT_CMD1 -f 'bestvideo[height<=720]+bestaudio/best[height<=720]/best'" ;;
            *) YT_CMD1="$YT_CMD1 -f 'best'" ;;
          esac
          YT_CMD1="$YT_CMD1 --merge-output-format mp4"
          
          echo "Running: $YT_CMD1 -o '$OUTPUT_FILE' '$VIDEO_URL'"
          if eval "$YT_CMD1 -o '$OUTPUT_FILE' '$VIDEO_URL'" 2>&1; then
            if [ -f "$OUTPUT_FILE" ] || [ -n "$(ls downloads/ 2>/dev/null)" ]; then
              DOWNLOAD_SUCCESS=true
              echo "✓ tv_embedded client download successful"
            fi
          fi
          
          # Attempt 2: web client with cookies (often works better)
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "=== Attempt 2: yt-dlp with web client ==="
            YT_CMD2="yt-dlp --verbose --no-warnings $COOKIES_OPT"
            YT_CMD2="$YT_CMD2 --extractor-args 'youtube:player_client=web'"
            YT_CMD2="$YT_CMD2 -f 'best' --merge-output-format mp4"
            
            echo "Running: $YT_CMD2 -o '$OUTPUT_FILE' '$VIDEO_URL'"
            if eval "$YT_CMD2 -o '$OUTPUT_FILE' '$VIDEO_URL'" 2>&1; then
              if [ -f "$OUTPUT_FILE" ] || [ -n "$(ls downloads/ 2>/dev/null)" ]; then
                DOWNLOAD_SUCCESS=true
                echo "✓ web client download successful"
              fi
            fi
          fi
          
          # Attempt 3: ios client (sometimes bypasses)
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "=== Attempt 3: yt-dlp with ios client ==="
            YT_CMD3="yt-dlp --verbose --no-warnings $COOKIES_OPT"
            YT_CMD3="$YT_CMD3 --extractor-args 'youtube:player_client=ios'"
            YT_CMD3="$YT_CMD3 -f 'best' --merge-output-format mp4"
            
            echo "Running: $YT_CMD3 -o '$OUTPUT_FILE' '$VIDEO_URL'"
            if eval "$YT_CMD3 -o '$OUTPUT_FILE' '$VIDEO_URL'" 2>&1; then
              if [ -f "$OUTPUT_FILE" ] || [ -n "$(ls downloads/ 2>/dev/null)" ]; then
                DOWNLOAD_SUCCESS=true
                echo "✓ ios client download successful"
              fi
            fi
          fi
          
          # Attempt 4: android client
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "=== Attempt 4: yt-dlp with android client ==="
            YT_CMD4="yt-dlp --verbose --no-warnings $COOKIES_OPT"
            YT_CMD4="$YT_CMD4 --extractor-args 'youtube:player_client=android'"
            YT_CMD4="$YT_CMD4 -f 'best' --merge-output-format mp4"
            
            echo "Running: $YT_CMD4 -o '$OUTPUT_FILE' '$VIDEO_URL'"
            if eval "$YT_CMD4 -o '$OUTPUT_FILE' '$VIDEO_URL'" 2>&1; then
              if [ -f "$OUTPUT_FILE" ] || [ -n "$(ls downloads/ 2>/dev/null)" ]; then
                DOWNLOAD_SUCCESS=true
                echo "✓ android client download successful"
              fi
            fi
          fi
          
          # Attempt 5: Try without any special client but with cookies
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "=== Attempt 5: yt-dlp default with cookies ==="
            YT_CMD5="yt-dlp --verbose --no-warnings $COOKIES_OPT"
            YT_CMD5="$YT_CMD5 -f 'best' --merge-output-format mp4"
            
            echo "Running: $YT_CMD5 -o '$OUTPUT_FILE' '$VIDEO_URL'"
            if eval "$YT_CMD5 -o '$OUTPUT_FILE' '$VIDEO_URL'" 2>&1; then
              if [ -f "$OUTPUT_FILE" ] || [ -n "$(ls downloads/ 2>/dev/null)" ]; then
                DOWNLOAD_SUCCESS=true
                echo "✓ default client download successful"
              fi
            fi
          fi
          
          # Fallback to external services if yt-dlp fails
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "yt-dlp failed with all clients, trying alternative APIs..."
            
            # Try Y2Mate style APIs
            echo "=== Trying Y2Mate API ==="
            
            # First get video info
            Y2_ANALYZE=$(curl -s 'https://www.y2mate.com/mates/analyzeV2/ajax' \
              -H 'Content-Type: application/x-www-form-urlencoded' \
              --data-urlencode "k_query=$VIDEO_URL" \
              --data-urlencode "k_page=home" \
              --data-urlencode "hl=en" \
              --data-urlencode "q_auto=0" 2>/dev/null)
            
            echo "Y2Mate analyze response received"
            
            if echo "$Y2_ANALYZE" | jq -e '.links' > /dev/null 2>&1; then
              # Get 360p mp4 link
              VID_KEY=$(echo "$Y2_ANALYZE" | jq -r '.links.mp4."18".k // .links.mp4 | to_entries[0].value.k // empty' 2>/dev/null)
              VID=$(echo "$Y2_ANALYZE" | jq -r '.vid // empty' 2>/dev/null)
              
              if [ -n "$VID_KEY" ] && [ -n "$VID" ]; then
                echo "Found Y2Mate video key, converting..."
                
                Y2_CONVERT=$(curl -s 'https://www.y2mate.com/mates/convertV2/index' \
                  -H 'Content-Type: application/x-www-form-urlencoded' \
                  --data-urlencode "vid=$VID" \
                  --data-urlencode "k=$VID_KEY" 2>/dev/null)
                
                DOWNLOAD_URL=$(echo "$Y2_CONVERT" | jq -r '.dlink // empty' 2>/dev/null)
                
                if [ -n "$DOWNLOAD_URL" ] && [ "$DOWNLOAD_URL" != "null" ]; then
                  echo "Y2Mate download URL obtained, downloading..."
                  if curl -L -o "$OUTPUT_FILE" --max-time 600 "$DOWNLOAD_URL" 2>&1; then
                    if [ -f "$OUTPUT_FILE" ] && [ -s "$OUTPUT_FILE" ]; then
                      DOWNLOAD_SUCCESS=true
                      echo "✓ Y2Mate download successful"
                    fi
                  fi
                fi
              fi
            fi
          fi
          
          # Try Piped instances
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "Cobalt failed, trying Piped API..."
            
            # Try Piped instances
            PIPED_INSTANCES=(
              "https://pipedapi.kavin.rocks"
              "https://pipedapi.adminforge.de"
              "https://api.piped.yt"
            )
            
            for INSTANCE in "${PIPED_INSTANCES[@]}"; do
              echo "Trying Piped instance: $INSTANCE"
              
              VIDEO_INFO=$(curl -s --max-time 10 "$INSTANCE/streams/$VIDEO_ID" 2>/dev/null)
              
              if [ -n "$VIDEO_INFO" ] && echo "$VIDEO_INFO" | jq -e '.videoStreams' > /dev/null 2>&1; then
                # Get 360p video stream
                STREAM_URL=$(echo "$VIDEO_INFO" | jq -r '.videoStreams[] | select(.quality == "360p") | .url' | head -1)
                
                if [ -z "$STREAM_URL" ] || [ "$STREAM_URL" = "null" ]; then
                  # Fallback to any available stream
                  STREAM_URL=$(echo "$VIDEO_INFO" | jq -r '.videoStreams[0].url' | head -1)
                fi
                
                if [ -n "$STREAM_URL" ] && [ "$STREAM_URL" != "null" ]; then
                  echo "Found Piped stream URL, downloading..."
                  if curl -L -o "$OUTPUT_FILE" --max-time 300 "$STREAM_URL"; then
                    DOWNLOAD_SUCCESS=true
                    TITLE=$(echo "$VIDEO_INFO" | jq -r '.title' | tr -cd '[:alnum:] ._-' | head -c 100)
                    echo "Piped download successful from $INSTANCE"
                    break
                  fi
                fi
              fi
            done
          fi
          
          # Last resort: try Invidious instances
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "Piped failed, trying Invidious fallback..."
            
            INVIDIOUS_INSTANCES=(
              "https://inv.nadeko.net"
              "https://invidious.nerdvpn.de"
              "https://vid.puffyan.us"
              "https://y.com.sb"
            )
            
            for INSTANCE in "${INVIDIOUS_INSTANCES[@]}"; do
              echo "Trying Invidious instance: $INSTANCE"
              
              API_URL="$INSTANCE/api/v1/videos/$VIDEO_ID"
              VIDEO_INFO=$(curl -s --max-time 10 "$API_URL" 2>/dev/null)
              
              if [ -n "$VIDEO_INFO" ] && echo "$VIDEO_INFO" | jq -e '.formatStreams' > /dev/null 2>&1; then
                STREAM_URL=$(echo "$VIDEO_INFO" | jq -r '.formatStreams[] | select(.quality == "360p" or .qualityLabel == "360p") | .url' | head -1)
                
                if [ -z "$STREAM_URL" ] || [ "$STREAM_URL" = "null" ]; then
                  STREAM_URL=$(echo "$VIDEO_INFO" | jq -r '.formatStreams[0].url' | head -1)
                fi
                
                if [ -n "$STREAM_URL" ] && [ "$STREAM_URL" != "null" ]; then
                  echo "Found Invidious stream URL, downloading..."
                  if curl -L -o "$OUTPUT_FILE" --max-time 300 "$STREAM_URL"; then
                    DOWNLOAD_SUCCESS=true
                    TITLE=$(echo "$VIDEO_INFO" | jq -r '.title' | tr -cd '[:alnum:] ._-' | head -c 100)
                    echo "Invidious download successful from $INSTANCE"
                    break
                  fi
                fi
              fi
            done
          fi
          
          # Find the actual output file (might have different extension)
          ACTUAL_FILE=$(ls downloads/ | head -1)
          
          if [ -z "$ACTUAL_FILE" ] || [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "Download failed - no file found after all attempts"
            exit 1
          fi
          
          FULL_PATH="downloads/$ACTUAL_FILE"
          FILE_SIZE=$(stat -c%s "$FULL_PATH")
          
          echo "Downloaded: $ACTUAL_FILE ($FILE_SIZE bytes)"
          
          # Set outputs
          echo "filename=$ACTUAL_FILE" >> $GITHUB_OUTPUT
          echo "filepath=$FULL_PATH" >> $GITHUB_OUTPUT
          echo "filesize=$FILE_SIZE" >> $GITHUB_OUTPUT
          echo "title=$TITLE" >> $GITHUB_OUTPUT
      
      - name: Configure AWS CLI for R2
        if: steps.download.outputs.extract_mode != 'true'
        run: |
          aws configure set aws_access_key_id ${{ secrets.R2_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.R2_SECRET_ACCESS_KEY }}
          aws configure set default.region auto
      
      - name: Upload to R2
        if: steps.download.outputs.extract_mode != 'true'
        id: upload
        run: |
          JOB_ID="${{ github.event.inputs.job_id || github.event.client_payload.job_id }}"
          FILENAME="${{ steps.download.outputs.filename }}"
          FILEPATH="${{ steps.download.outputs.filepath }}"
          
          # Upload to R2
          R2_ENDPOINT="${{ secrets.R2_ENDPOINT }}"
          BUCKET_NAME="proxy-videos"
          
          # Upload video file to videos/${JOB_ID}/ directory
          aws s3 cp "$FILEPATH" "s3://${BUCKET_NAME}/videos/${JOB_ID}/${FILENAME}" \
            --endpoint-url "$R2_ENDPOINT" \
            --no-progress
          
          echo "Uploaded to R2: videos/${JOB_ID}/${FILENAME}"
          echo "r2_path=videos/${JOB_ID}/${FILENAME}" >> $GITHUB_OUTPUT
      
      - name: Callback to Worker
        if: always()
        run: |
          JOB_ID="${{ github.event.inputs.job_id || github.event.client_payload.job_id }}"
          CALLBACK_URL="${{ github.event.inputs.callback_url || github.event.client_payload.callback_url }}"
          EXTRACT_MODE="${{ steps.download.outputs.extract_mode }}"
          
          if [ "${{ job.status }}" = "success" ]; then
            STATUS="completed"
            TITLE="${{ steps.download.outputs.title }}"
            
            if [ "$EXTRACT_MODE" = "true" ]; then
              # URL extraction mode - send extracted URLs
              EXTRACTED_URLS="${{ steps.download.outputs.extracted_urls }}"
              
              # Escape newlines for JSON
              ESCAPED_URLS=$(echo "$EXTRACTED_URLS" | sed ':a;N;$!ba;s/\n/\\n/g')
              
              curl -X POST "$CALLBACK_URL" \
                -H "Content-Type: application/json" \
                -H "X-Job-Secret: ${{ secrets.JOB_SECRET }}" \
                -d "{
                  \"job_id\": \"$JOB_ID\",
                  \"status\": \"$STATUS\",
                  \"title\": \"$TITLE\",
                  \"extract_url_only\": true,
                  \"extracted_urls\": \"$ESCAPED_URLS\"
                }"
            else
              # Normal download mode
              FILENAME="${{ steps.download.outputs.filename }}"
              FILESIZE="${{ steps.download.outputs.filesize }}"
              R2_PATH="${{ steps.upload.outputs.r2_path }}"
              
              curl -X POST "$CALLBACK_URL" \
                -H "Content-Type: application/json" \
                -H "X-Job-Secret: ${{ secrets.JOB_SECRET }}" \
                -d "{
                  \"job_id\": \"$JOB_ID\",
                  \"status\": \"$STATUS\",
                  \"filename\": \"$FILENAME\",
                  \"filesize\": $FILESIZE,
                  \"title\": \"$TITLE\",
                  \"r2_path\": \"$R2_PATH\"
                }"
            fi
          else
            STATUS="failed"
            curl -X POST "$CALLBACK_URL" \
              -H "Content-Type: application/json" \
              -H "X-Job-Secret: ${{ secrets.JOB_SECRET }}" \
              -d "{
                \"job_id\": \"$JOB_ID\",
                \"status\": \"$STATUS\",
                \"error\": \"Download or URL extraction failed\"
              }"
          fi
          
          echo "Callback sent with status: $STATUS"
