name: YouTube Download

on:
  workflow_dispatch:
    inputs:
      job_id:
        description: 'Unique job ID'
        required: true
        type: string
      video_url:
        description: 'YouTube video URL'
        required: true
        type: string
      format:
        description: 'Download format (best, bestaudio, 720p, 1080p, etc.)'
        required: false
        default: 'best'
        type: string
      audio_only:
        description: 'Extract audio only (true/false)'
        required: false
        default: 'false'
        type: string
      callback_url:
        description: 'Callback URL after completion'
        required: true
        type: string
  repository_dispatch:
    types: [yt_download]

jobs:
  download:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install yt-dlp and ffmpeg
        run: |
          pip install yt-dlp
          sudo apt-get update
          sudo apt-get install -y ffmpeg
      
      - name: Create output directory
        run: mkdir -p downloads
      
      - name: Download video
        id: download
        run: |
          VIDEO_URL="${{ github.event.inputs.video_url || github.event.client_payload.url }}"
          FORMAT="${{ github.event.inputs.format || github.event.client_payload.format }}"
          AUDIO_ONLY="${{ github.event.inputs.audio_only || github.event.client_payload.audio_only }}"
          JOB_ID="${{ github.event.inputs.job_id || github.event.client_payload.job_id }}"
          
          echo "Downloading: $VIDEO_URL"
          echo "Format: $FORMAT"
          echo "Audio only: $AUDIO_ONLY"
          
          # Build yt-dlp command
          YT_CMD="yt-dlp --no-warnings --progress"
          
          if [ "$AUDIO_ONLY" = "true" ]; then
            YT_CMD="$YT_CMD -x --audio-format mp3 --audio-quality 0"
            EXT="mp3"
          else
            case "$FORMAT" in
              "best")
                YT_CMD="$YT_CMD -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "1080p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/best[height<=1080]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "720p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/best[height<=720]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "480p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=480][ext=mp4]+bestaudio[ext=m4a]/best[height<=480]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "360p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=360][ext=mp4]+bestaudio[ext=m4a]/best[height<=360]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "bestaudio")
                YT_CMD="$YT_CMD -x --audio-format mp3 --audio-quality 0"
                EXT="mp3"
                ;;
              *)
                YT_CMD="$YT_CMD -f '$FORMAT' --merge-output-format mp4"
                EXT="mp4"
                ;;
            esac
          fi
          
          # Get video title for filename
          TITLE=$(yt-dlp --get-title "$VIDEO_URL" 2>/dev/null | head -1 | tr -cd '[:alnum:] ._-' | head -c 100)
          if [ -z "$TITLE" ]; then
            TITLE="video_$JOB_ID"
          fi
          
          SAFE_TITLE=$(echo "$TITLE" | tr ' ' '_' | tr -cd '[:alnum:]._-')
          OUTPUT_FILE="downloads/${SAFE_TITLE}.${EXT}"
          
          echo "Output file: $OUTPUT_FILE"
          
          # Execute download
          eval "$YT_CMD -o '$OUTPUT_FILE' '$VIDEO_URL'"
          
          # Find the actual output file (might have different extension)
          ACTUAL_FILE=$(ls downloads/ | head -1)
          
          if [ -z "$ACTUAL_FILE" ]; then
            echo "Download failed - no file found"
            exit 1
          fi
          
          FULL_PATH="downloads/$ACTUAL_FILE"
          FILE_SIZE=$(stat -c%s "$FULL_PATH")
          
          echo "Downloaded: $ACTUAL_FILE ($FILE_SIZE bytes)"
          
          # Set outputs
          echo "filename=$ACTUAL_FILE" >> $GITHUB_OUTPUT
          echo "filepath=$FULL_PATH" >> $GITHUB_OUTPUT
          echo "filesize=$FILE_SIZE" >> $GITHUB_OUTPUT
          echo "title=$TITLE" >> $GITHUB_OUTPUT
      
      - name: Configure AWS CLI for R2
        run: |
          aws configure set aws_access_key_id ${{ secrets.R2_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.R2_SECRET_ACCESS_KEY }}
          aws configure set default.region auto
      
      - name: Upload to R2
        id: upload
        run: |
          JOB_ID="${{ github.event.inputs.job_id || github.event.client_payload.job_id }}"
          FILENAME="${{ steps.download.outputs.filename }}"
          FILEPATH="${{ steps.download.outputs.filepath }}"
          
          # Upload to R2
          R2_ENDPOINT="${{ secrets.R2_ENDPOINT }}"
          BUCKET_NAME="proxy-videos"
          
          # Upload video file to videos/${JOB_ID}/ directory
          aws s3 cp "$FILEPATH" "s3://${BUCKET_NAME}/videos/${JOB_ID}/${FILENAME}" \
            --endpoint-url "$R2_ENDPOINT" \
            --no-progress
          
          echo "Uploaded to R2: videos/${JOB_ID}/${FILENAME}"
          echo "r2_path=videos/${JOB_ID}/${FILENAME}" >> $GITHUB_OUTPUT
      
      - name: Callback to Worker
        if: always()
        run: |
          JOB_ID="${{ github.event.inputs.job_id || github.event.client_payload.job_id }}"
          CALLBACK_URL="${{ github.event.inputs.callback_url || github.event.client_payload.callback_url }}"
          
          if [ "${{ job.status }}" = "success" ]; then
            STATUS="completed"
            FILENAME="${{ steps.download.outputs.filename }}"
            FILESIZE="${{ steps.download.outputs.filesize }}"
            TITLE="${{ steps.download.outputs.title }}"
            R2_PATH="${{ steps.upload.outputs.r2_path }}"
            
            curl -X POST "$CALLBACK_URL" \
              -H "Content-Type: application/json" \
              -H "X-Job-Secret: ${{ secrets.JOB_SECRET }}" \
              -d "{
                \"job_id\": \"$JOB_ID\",
                \"status\": \"$STATUS\",
                \"filename\": \"$FILENAME\",
                \"filesize\": $FILESIZE,
                \"title\": \"$TITLE\",
                \"r2_path\": \"$R2_PATH\"
              }"
          else
            STATUS="failed"
            curl -X POST "$CALLBACK_URL" \
              -H "Content-Type: application/json" \
              -H "X-Job-Secret: ${{ secrets.JOB_SECRET }}" \
              -d "{
                \"job_id\": \"$JOB_ID\",
                \"status\": \"$STATUS\",
                \"error\": \"Download or upload failed\"
              }"
          fi
          
          echo "Callback sent with status: $STATUS"
