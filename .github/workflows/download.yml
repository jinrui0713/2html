name: YouTube Download

on:
  workflow_dispatch:
    inputs:
      job_id:
        description: 'Unique job ID'
        required: true
        type: string
      video_url:
        description: 'YouTube video URL'
        required: true
        type: string
      format:
        description: 'Download format (best, bestaudio, 720p, 1080p, etc.)'
        required: false
        default: 'best'
        type: string
      audio_only:
        description: 'Extract audio only (true/false)'
        required: false
        default: 'false'
        type: string
      callback_url:
        description: 'Callback URL after completion'
        required: true
        type: string
  repository_dispatch:
    types: [yt_download]

jobs:
  download:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Debug - Show event payload
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "Job ID (inputs): ${{ github.event.inputs.job_id }}"
          echo "Job ID (client_payload): ${{ github.event.client_payload.job_id }}"
          echo "URL (inputs): ${{ github.event.inputs.video_url }}"
          echo "URL (client_payload): ${{ github.event.client_payload.url }}"
          echo "Format (inputs): ${{ github.event.inputs.format }}"
          echo "Format (client_payload): ${{ github.event.client_payload.format }}"
          echo "Callback (inputs): ${{ github.event.inputs.callback_url }}"
          echo "Callback (client_payload): ${{ github.event.client_payload.callback_url }}"
      
      - name: Install yt-dlp and ffmpeg
        run: |
          # Install latest yt-dlp from GitHub releases (most up-to-date)
          sudo curl -L https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp -o /usr/local/bin/yt-dlp
          sudo chmod a+rx /usr/local/bin/yt-dlp
          yt-dlp --version
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq
          pip install awscli
      
      - name: Create output directory and setup cookies
        run: |
          mkdir -p downloads
          # Create cookies file if YOUTUBE_COOKIES secret is provided
          # The secret should be base64 encoded
          if [ -n "${{ secrets.YOUTUBE_COOKIES }}" ]; then
            echo "${{ secrets.YOUTUBE_COOKIES }}" | base64 -d > cookies_raw.txt 2>/dev/null || echo "${{ secrets.YOUTUBE_COOKIES }}" > cookies_raw.txt
            # Convert Windows CRLF to Unix LF
            sed 's/\r$//' cookies_raw.txt > cookies.txt
            rm -f cookies_raw.txt
            echo "YouTube cookies file created"
            echo "Cookies file size: $(wc -c < cookies.txt) bytes"
            echo "Cookies file lines: $(wc -l < cookies.txt)"
            # Verify format
            if head -1 cookies.txt | grep -q "Netscape"; then
              echo "âœ“ Valid Netscape cookie format detected"
            else
              echo "First line: $(head -1 cookies.txt | cut -c1-30)"
            fi
            # Count cookie entries (lines not starting with #)
            COOKIE_COUNT=$(grep -v '^#' cookies.txt | grep -v '^$' | wc -l)
            echo "Cookie entries found: $COOKIE_COUNT"
          else
            echo "Warning: YOUTUBE_COOKIES secret not set"
          fi
      
      - name: Download video
        id: download
        env:
          YOUTUBE_COOKIES: ${{ secrets.YOUTUBE_COOKIES }}
        run: |
          VIDEO_URL="${{ github.event.inputs.video_url || github.event.client_payload.url }}"
          FORMAT="${{ github.event.inputs.format || github.event.client_payload.format }}"
          AUDIO_ONLY="${{ github.event.inputs.audio_only || github.event.client_payload.audio_only }}"
          JOB_ID="${{ github.event.inputs.job_id || github.event.client_payload.job_id }}"
          
          echo "Downloading: $VIDEO_URL"
          echo "Format: $FORMAT"
          echo "Audio only: $AUDIO_ONLY"
          
          # Extract video ID from YouTube URL
          VIDEO_ID=$(echo "$VIDEO_URL" | grep -oP '(?:v=|youtu\.be/|shorts/)([a-zA-Z0-9_-]{11})' | head -1 | sed 's/v=//;s/youtu\.be\///;s/shorts\///')
          if [ -z "$VIDEO_ID" ]; then
            VIDEO_ID=$(echo "$VIDEO_URL" | grep -oE '[a-zA-Z0-9_-]{11}')
          fi
          echo "Video ID: $VIDEO_ID"
          
          # Build yt-dlp command with anti-bot options
          # (Individual commands are built in each attempt section)
          
          if [ "$AUDIO_ONLY" = "true" ]; then
            YT_CMD="$YT_CMD -x --audio-format mp3 --audio-quality 0"
            EXT="mp3"
          else
            case "$FORMAT" in
              "best")
                YT_CMD="$YT_CMD -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "1080p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/best[height<=1080]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "720p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/best[height<=720]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "480p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=480][ext=mp4]+bestaudio[ext=m4a]/best[height<=480]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "360p")
                YT_CMD="$YT_CMD -f 'bestvideo[height<=360][ext=mp4]+bestaudio[ext=m4a]/best[height<=360]' --merge-output-format mp4"
                EXT="mp4"
                ;;
              "bestaudio")
                YT_CMD="$YT_CMD -x --audio-format mp3 --audio-quality 0"
                EXT="mp3"
                ;;
              *)
                YT_CMD="$YT_CMD -f '$FORMAT' --merge-output-format mp4"
                EXT="mp4"
                ;;
            esac
          fi
          
          # Get video title for filename
          TITLE=$(yt-dlp --get-title "$VIDEO_URL" 2>/dev/null | head -1 | tr -cd '[:alnum:] ._-' | head -c 100)
          if [ -z "$TITLE" ]; then
            TITLE="video_$JOB_ID"
          fi
          
          SAFE_TITLE=$(echo "$TITLE" | tr ' ' '_' | tr -cd '[:alnum:]._-')
          if [ -z "$SAFE_TITLE" ]; then
            SAFE_TITLE="video_$JOB_ID"
          fi
          OUTPUT_FILE="downloads/${SAFE_TITLE}.${EXT}"
          
          echo "Output file: $OUTPUT_FILE"
          
          # Try yt-dlp with different configurations
          DOWNLOAD_SUCCESS=false
          
          # Attempt 1: tv_embedded client (often bypasses restrictions)
          echo "=== Attempt 1: yt-dlp with tv_embedded client ==="
          YT_CMD1="yt-dlp --no-warnings"
          if [ -f "cookies.txt" ]; then
            YT_CMD1="$YT_CMD1 --cookies cookies.txt"
          fi
          YT_CMD1="$YT_CMD1 --extractor-args 'youtube:player_client=tv_embedded'"
          case "$FORMAT" in
            "360p") YT_CMD1="$YT_CMD1 -f 'bestvideo[height<=360]+bestaudio/best[height<=360]/best'" ;;
            "480p") YT_CMD1="$YT_CMD1 -f 'bestvideo[height<=480]+bestaudio/best[height<=480]/best'" ;;
            "720p") YT_CMD1="$YT_CMD1 -f 'bestvideo[height<=720]+bestaudio/best[height<=720]/best'" ;;
            *) YT_CMD1="$YT_CMD1 -f 'best'" ;;
          esac
          YT_CMD1="$YT_CMD1 --merge-output-format mp4"
          
          if eval "$YT_CMD1 -o '$OUTPUT_FILE' '$VIDEO_URL'" 2>&1; then
            if [ -f "$OUTPUT_FILE" ] || [ -n "$(ls downloads/ 2>/dev/null)" ]; then
              DOWNLOAD_SUCCESS=true
              echo "tv_embedded client download successful"
            fi
          fi
          
          # Attempt 2: mweb client (mobile web)
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "=== Attempt 2: yt-dlp with mweb client ==="
            YT_CMD2="yt-dlp --no-warnings"
            if [ -f "cookies.txt" ]; then
              YT_CMD2="$YT_CMD2 --cookies cookies.txt"
            fi
            YT_CMD2="$YT_CMD2 --extractor-args 'youtube:player_client=mweb'"
            YT_CMD2="$YT_CMD2 -f 'best' --merge-output-format mp4"
            
            if eval "$YT_CMD2 -o '$OUTPUT_FILE' '$VIDEO_URL'" 2>&1; then
              if [ -f "$OUTPUT_FILE" ] || [ -n "$(ls downloads/ 2>/dev/null)" ]; then
                DOWNLOAD_SUCCESS=true
                echo "mweb client download successful"
              fi
            fi
          fi
          
          # Attempt 3: mediaconnect client
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "=== Attempt 3: yt-dlp with mediaconnect client ==="
            YT_CMD3="yt-dlp --no-warnings"
            if [ -f "cookies.txt" ]; then
              YT_CMD3="$YT_CMD3 --cookies cookies.txt"
            fi
            YT_CMD3="$YT_CMD3 --extractor-args 'youtube:player_client=mediaconnect'"
            YT_CMD3="$YT_CMD3 -f 'best' --merge-output-format mp4"
            
            if eval "$YT_CMD3 -o '$OUTPUT_FILE' '$VIDEO_URL'" 2>&1; then
              if [ -f "$OUTPUT_FILE" ] || [ -n "$(ls downloads/ 2>/dev/null)" ]; then
                DOWNLOAD_SUCCESS=true
                echo "mediaconnect client download successful"
              fi
            fi
          fi
          
          # Attempt 4: Try without any special options (default)
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "=== Attempt 4: yt-dlp default ==="
            YT_CMD4="yt-dlp --no-warnings"
            if [ -f "cookies.txt" ]; then
              YT_CMD4="$YT_CMD4 --cookies cookies.txt"
            fi
            YT_CMD4="$YT_CMD4 -f 'best' --merge-output-format mp4"
            
            if eval "$YT_CMD4 -o '$OUTPUT_FILE' '$VIDEO_URL'" 2>&1; then
              if [ -f "$OUTPUT_FILE" ] || [ -n "$(ls downloads/ 2>/dev/null)" ]; then
                DOWNLOAD_SUCCESS=true
                echo "default client download successful"
              fi
            fi
          fi
          
          # Fallback to external services if yt-dlp fails
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "yt-dlp failed with all clients, trying Cobalt API..."
            
            # Try multiple Cobalt instances
            COBALT_INSTANCES=(
              "https://api.cobalt.tools"
              "https://cobalt-api.kwiatekmiki.com"
              "https://cobalt.canine.tools"
            )
            
            for COBALT_URL in "${COBALT_INSTANCES[@]}"; do
              echo "Trying Cobalt instance: $COBALT_URL"
              
              # Try new v2 API format first
              COBALT_RESPONSE=$(curl -s -X POST "$COBALT_URL/api/json" \
                -H "Accept: application/json" \
                -H "Content-Type: application/json" \
                -d "{\"url\": \"$VIDEO_URL\", \"vQuality\": \"360\", \"filenamePattern\": \"basic\"}" 2>/dev/null)
              
              echo "Cobalt response: $COBALT_RESPONSE"
              
              DOWNLOAD_URL=$(echo "$COBALT_RESPONSE" | jq -r '.url // empty')
              
              if [ -n "$DOWNLOAD_URL" ] && [ "$DOWNLOAD_URL" != "null" ]; then
                echo "Cobalt returned URL: $DOWNLOAD_URL"
                if curl -L -o "$OUTPUT_FILE" --max-time 300 "$DOWNLOAD_URL" 2>&1; then
                  if [ -f "$OUTPUT_FILE" ] && [ -s "$OUTPUT_FILE" ]; then
                    DOWNLOAD_SUCCESS=true
                    echo "Cobalt download successful from $COBALT_URL"
                    break
                  fi
                fi
              fi
            done
          fi
          
          # Try Piped instances
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "Cobalt failed, trying Piped API..."
            
            # Try Piped instances
            PIPED_INSTANCES=(
              "https://pipedapi.kavin.rocks"
              "https://pipedapi.adminforge.de"
              "https://api.piped.yt"
            )
            
            for INSTANCE in "${PIPED_INSTANCES[@]}"; do
              echo "Trying Piped instance: $INSTANCE"
              
              VIDEO_INFO=$(curl -s --max-time 10 "$INSTANCE/streams/$VIDEO_ID" 2>/dev/null)
              
              if [ -n "$VIDEO_INFO" ] && echo "$VIDEO_INFO" | jq -e '.videoStreams' > /dev/null 2>&1; then
                # Get 360p video stream
                STREAM_URL=$(echo "$VIDEO_INFO" | jq -r '.videoStreams[] | select(.quality == "360p") | .url' | head -1)
                
                if [ -z "$STREAM_URL" ] || [ "$STREAM_URL" = "null" ]; then
                  # Fallback to any available stream
                  STREAM_URL=$(echo "$VIDEO_INFO" | jq -r '.videoStreams[0].url' | head -1)
                fi
                
                if [ -n "$STREAM_URL" ] && [ "$STREAM_URL" != "null" ]; then
                  echo "Found Piped stream URL, downloading..."
                  if curl -L -o "$OUTPUT_FILE" --max-time 300 "$STREAM_URL"; then
                    DOWNLOAD_SUCCESS=true
                    TITLE=$(echo "$VIDEO_INFO" | jq -r '.title' | tr -cd '[:alnum:] ._-' | head -c 100)
                    echo "Piped download successful from $INSTANCE"
                    break
                  fi
                fi
              fi
            done
          fi
          
          # Last resort: try Invidious instances
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "Piped failed, trying Invidious fallback..."
            
            INVIDIOUS_INSTANCES=(
              "https://inv.nadeko.net"
              "https://invidious.nerdvpn.de"
              "https://vid.puffyan.us"
              "https://y.com.sb"
            )
            
            for INSTANCE in "${INVIDIOUS_INSTANCES[@]}"; do
              echo "Trying Invidious instance: $INSTANCE"
              
              API_URL="$INSTANCE/api/v1/videos/$VIDEO_ID"
              VIDEO_INFO=$(curl -s --max-time 10 "$API_URL" 2>/dev/null)
              
              if [ -n "$VIDEO_INFO" ] && echo "$VIDEO_INFO" | jq -e '.formatStreams' > /dev/null 2>&1; then
                STREAM_URL=$(echo "$VIDEO_INFO" | jq -r '.formatStreams[] | select(.quality == "360p" or .qualityLabel == "360p") | .url' | head -1)
                
                if [ -z "$STREAM_URL" ] || [ "$STREAM_URL" = "null" ]; then
                  STREAM_URL=$(echo "$VIDEO_INFO" | jq -r '.formatStreams[0].url' | head -1)
                fi
                
                if [ -n "$STREAM_URL" ] && [ "$STREAM_URL" != "null" ]; then
                  echo "Found Invidious stream URL, downloading..."
                  if curl -L -o "$OUTPUT_FILE" --max-time 300 "$STREAM_URL"; then
                    DOWNLOAD_SUCCESS=true
                    TITLE=$(echo "$VIDEO_INFO" | jq -r '.title' | tr -cd '[:alnum:] ._-' | head -c 100)
                    echo "Invidious download successful from $INSTANCE"
                    break
                  fi
                fi
              fi
            done
          fi
          
          # Find the actual output file (might have different extension)
          ACTUAL_FILE=$(ls downloads/ | head -1)
          
          if [ -z "$ACTUAL_FILE" ] || [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "Download failed - no file found after all attempts"
            exit 1
          fi
          
          FULL_PATH="downloads/$ACTUAL_FILE"
          FILE_SIZE=$(stat -c%s "$FULL_PATH")
          
          echo "Downloaded: $ACTUAL_FILE ($FILE_SIZE bytes)"
          
          # Set outputs
          echo "filename=$ACTUAL_FILE" >> $GITHUB_OUTPUT
          echo "filepath=$FULL_PATH" >> $GITHUB_OUTPUT
          echo "filesize=$FILE_SIZE" >> $GITHUB_OUTPUT
          echo "title=$TITLE" >> $GITHUB_OUTPUT
      
      - name: Configure AWS CLI for R2
        run: |
          aws configure set aws_access_key_id ${{ secrets.R2_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.R2_SECRET_ACCESS_KEY }}
          aws configure set default.region auto
      
      - name: Upload to R2
        id: upload
        run: |
          JOB_ID="${{ github.event.inputs.job_id || github.event.client_payload.job_id }}"
          FILENAME="${{ steps.download.outputs.filename }}"
          FILEPATH="${{ steps.download.outputs.filepath }}"
          
          # Upload to R2
          R2_ENDPOINT="${{ secrets.R2_ENDPOINT }}"
          BUCKET_NAME="proxy-videos"
          
          # Upload video file to videos/${JOB_ID}/ directory
          aws s3 cp "$FILEPATH" "s3://${BUCKET_NAME}/videos/${JOB_ID}/${FILENAME}" \
            --endpoint-url "$R2_ENDPOINT" \
            --no-progress
          
          echo "Uploaded to R2: videos/${JOB_ID}/${FILENAME}"
          echo "r2_path=videos/${JOB_ID}/${FILENAME}" >> $GITHUB_OUTPUT
      
      - name: Callback to Worker
        if: always()
        run: |
          JOB_ID="${{ github.event.inputs.job_id || github.event.client_payload.job_id }}"
          CALLBACK_URL="${{ github.event.inputs.callback_url || github.event.client_payload.callback_url }}"
          
          if [ "${{ job.status }}" = "success" ]; then
            STATUS="completed"
            FILENAME="${{ steps.download.outputs.filename }}"
            FILESIZE="${{ steps.download.outputs.filesize }}"
            TITLE="${{ steps.download.outputs.title }}"
            R2_PATH="${{ steps.upload.outputs.r2_path }}"
            
            curl -X POST "$CALLBACK_URL" \
              -H "Content-Type: application/json" \
              -H "X-Job-Secret: ${{ secrets.JOB_SECRET }}" \
              -d "{
                \"job_id\": \"$JOB_ID\",
                \"status\": \"$STATUS\",
                \"filename\": \"$FILENAME\",
                \"filesize\": $FILESIZE,
                \"title\": \"$TITLE\",
                \"r2_path\": \"$R2_PATH\"
              }"
          else
            STATUS="failed"
            curl -X POST "$CALLBACK_URL" \
              -H "Content-Type: application/json" \
              -H "X-Job-Secret: ${{ secrets.JOB_SECRET }}" \
              -d "{
                \"job_id\": \"$JOB_ID\",
                \"status\": \"$STATUS\",
                \"error\": \"Download or upload failed\"
              }"
          fi
          
          echo "Callback sent with status: $STATUS"
